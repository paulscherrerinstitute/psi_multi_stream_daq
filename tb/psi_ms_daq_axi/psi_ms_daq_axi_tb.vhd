------------------------------------------------------------------------------
--  Copyright (c) 2019 by Paul Scherrer Institute, Switzerland
--  All rights reserved.
--  Authors: Oliver Bruendler
------------------------------------------------------------------------------

------------------------------------------------------------
-- Testbench generated by TbGen.py
------------------------------------------------------------
-- see Library/Python/TbGenerator

------------------------------------------------------------
-- Libraries
------------------------------------------------------------
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

library work;
	use work.psi_common_math_pkg.all;
	use work.psi_common_array_pkg.all;
	use work.psi_ms_daq_pkg.all;

library work;
	use work.psi_tb_txt_util.all;
	use work.psi_tb_compare_pkg.all;
	use work.psi_tb_axi_pkg.all;
	use work.psi_ms_daq_axi_tb_pkg.all;
	use work.psi_ms_daq_axi_tb_str0_pkg.all;
	use work.psi_ms_daq_axi_tb_str1_pkg.all;
	use work.psi_ms_daq_axi_tb_str2_pkg.all;
	use work.psi_ms_daq_axi_tb_str3_pkg.all;


------------------------------------------------------------
-- Entity Declaration
------------------------------------------------------------
entity psi_ms_daq_axi_tb is
end entity;

------------------------------------------------------------
-- Architecture
------------------------------------------------------------
architecture sim of psi_ms_daq_axi_tb is

	-- TB Control
	signal TbRunning 	: boolean 	:= true;
	signal PrintIrq_c	: boolean	:= PrintDefault_c;

	-- Constants
	constant StrCount_c	: integer	:= 4;
	constant ClkFreq_c	: t_areal	:= (0=>250.0e6,	1=>125.0e6,	2=>80.0e6,	3=>200.0e6);
	
	-- Axi Memory
	constant ID_WIDTH 		: integer 	:= 1;
	constant ADDR_WIDTH 	: integer	:= 32;
	constant USER_WIDTH		: integer	:= 1;
	constant DATA_WIDTH		: integer	:= 64;
	constant BYTE_WIDTH		: integer	:= DATA_WIDTH/8;
	
	subtype ID_RANGE is natural range ID_WIDTH-1 downto 0;
	subtype ADDR_RANGE is natural range ADDR_WIDTH-1 downto 0;
	subtype USER_RANGE is natural range USER_WIDTH-1 downto 0;
	subtype DATA_RANGE is natural range DATA_WIDTH-1 downto 0;
	subtype BYTE_RANGE is natural range BYTE_WIDTH-1 downto 0;
	
	subtype axi_ms_t is axi_ms_r (	arid(ID_RANGE), awid(ID_RANGE),
									araddr(ADDR_RANGE), awaddr(ADDR_RANGE),
									aruser(USER_RANGE), awuser(USER_RANGE), wuser(USER_RANGE),
									wdata(DATA_RANGE),
									wstrb(BYTE_RANGE));
	
	subtype axi_sm_t is axi_sm_r (	rid(ID_RANGE), bid(ID_RANGE),
									ruser(USER_RANGE), buser(USER_RANGE),
									rdata(DATA_RANGE));	

	-- Axi Registers
	constant REG_ID_WIDTH 		: integer 	:= 1;
	constant REG_ADDR_WIDTH 	: integer	:= 16;
	constant REG_USER_WIDTH		: integer	:= 1;
	constant REG_DATA_WIDTH		: integer	:= 32;
	constant REG_BYTE_WIDTH		: integer	:= REG_DATA_WIDTH/8;
	
	subtype REG_ID_RANGE is natural range REG_ID_WIDTH-1 downto 0;
	subtype REG_ADDR_RANGE is natural range REG_ADDR_WIDTH-1 downto 0;
	subtype REG_USER_RANGE is natural range REG_USER_WIDTH-1 downto 0;
	subtype REG_DATA_RANGE is natural range REG_DATA_WIDTH-1 downto 0;
	subtype REG_BYTE_RANGE is natural range REG_BYTE_WIDTH-1 downto 0;
	
	subtype reg_axi_ms_t is axi_ms_r (	arid(REG_ID_RANGE), awid(REG_ID_RANGE),
										araddr(REG_ADDR_RANGE), awaddr(REG_ADDR_RANGE),
										aruser(REG_USER_RANGE), awuser(REG_USER_RANGE), wuser(REG_USER_RANGE),
										wdata(REG_DATA_RANGE),
										wstrb(REG_BYTE_RANGE));
	
	subtype reg_axi_sm_t is axi_sm_r (	rid(REG_ID_RANGE), bid(REG_ID_RANGE),
										ruser(REG_USER_RANGE), buser(REG_USER_RANGE),
										rdata(REG_DATA_RANGE));										
	

	-- Port signals	
	signal Str_Clk			: std_logic_vector(StrCount_c-1 downto 0)	:= (others => '0');
	signal Str0_Data		: std_logic_vector(7 downto 0)				:= (others => '0');
	signal Str1_Data		: std_logic_vector(15 downto 0)				:= (others => '0');
	signal Str2_Data		: std_logic_vector(15 downto 0)				:= (others => '0');
	signal Str3_Data		: std_logic_vector(31 downto 0)				:= (others => '0');
	signal Timestamp		: t_aslv64(StrCount_c-1 downto 0)			:= (others => (others => '0'));
	signal Str_Vld			: std_logic_vector(StrCount_c-1 downto 0)	:= (others => '0');
	signal Str_Rdy			: std_logic_vector(StrCount_c-1 downto 0)	:= (others => '0');
	signal Str_Trig			: std_logic_vector(StrCount_c-1 downto 0)	:= (others => '0');
	signal M_Axi_Aclk		: std_logic									:= '0';
	signal S_Axi_Aclk		: std_logic									:= '0';
	signal M_Axi_Aresetn	: std_logic									:= '0';
	signal S_Axi_Aresetn	: std_logic									:= '0';
	signal Irq				: std_logic									:= '0';
	signal axi_ms			: axi_ms_t;
	signal axi_sm 			: axi_sm_t;
	signal reg_axi_ms		: reg_axi_ms_t;
	signal reg_axi_sm		: reg_axi_sm_t;
	
	
	procedure IrqHandler(	signal	clk			: in	std_logic;
							signal	rqst		: out 	axi_ms_r;
							signal	rsp			: in	axi_sm_r) is
		variable v : integer;
		variable slv : std_logic_vector(31 downto 0);
	begin
		print("###################################### IRQ Detected #########################################", PrintIrq_c);
		wait until rising_edge(clk);
		AxiRead32(16#0010#, v, clk, rqst, rsp);
		slv := std_logic_vector(to_unsigned(v, 32));
		AxiWrite32(16#0010#, v, clk, rqst, rsp);
		wait until rising_edge(clk);
		for i in 0 to StrCount_c-1 loop
			if slv(i) = '1' then
				case i is 
					when 0 => Str0Handler(clk, rqst, rsp);
					when 1 => Str1Handler(clk, rqst, rsp);
					when 2 => Str2Handler(clk, rqst, rsp);
					when 3 => Str3Handler(clk, rqst, rsp);
					when others => null;
				end case;
			end if;
		end loop;
		-- Delay to ensure IRQ is cleared
		for i in 0 to 5 loop
			wait until rising_edge(clk);
		end loop;
	end procedure;								
							
	
begin
	------------------------------------------------------------
	-- DUT Instantiation
	------------------------------------------------------------
	i_dut : entity work.psi_ms_daq_axi
		generic map (
			Streams_g				=> StrCount_c,
			StreamWidth_g			=> (0=>8, 		1=>16, 			2=>16, 		3=>32),
			StreamPrio_g			=> (0=>1, 		1=>3,  			2=>2,  		3=>2),
			StreamBuffer_g			=> (0=>32, 		1=>128, 		2=>128, 	3=>128),
			StreamTimeout_g			=> (0=>5.0e-6,	1=>1.0e-3,		2=>1.0e-3,	3=>1.0e-3),
			StreamClkFreq_g			=> ClkFreq_c,
			StreamTsFifoDepth_g		=> (0=>16,		1=>16,			2=>16,		3=>16),
			StreamUseTs_g			=> (0=>true,	1=>true,		2=>true,	3=>false),
			MaxWindows_g			=> work.psi_ms_daq_axi_tb_pkg.MaxWindows_c,
			MinBurstSize_g			=> 16,
			MaxBurstSize_g			=> 128,
			AxiFifoDepth_g			=> 512,
			AxiSlaveIdWidth_g		=> 1
		)
		port map (
			Str_Clk						=> Str_Clk,
			Str_Data(0)(7 downto 0)		=> Str0_Data,
			Str_Data(0)(63 downto 8)	=> (others => '0'),
			Str_Data(1)(15 downto 0)	=> Str1_Data,
			Str_Data(1)(63 downto 16)	=> (others => '0'),
			Str_Data(2)(15 downto 0)	=> Str2_Data,
			Str_Data(2)(63 downto 16)	=> (others => '0'),
			Str_Data(3)(31 downto 0)	=> Str3_Data,
			Str_Data(3)(63 downto 32)	=> (others => '0'),
			Str_Ts						=> Timestamp,
			Str_Vld						=> Str_Vld,
			Str_Rdy						=> Str_Rdy,
			Str_Trig					=> Str_Trig,
			Irq							=> Irq,
			S_Axi_Aclk					=> S_Axi_Aclk,
			S_Axi_Aresetn				=> S_Axi_Aresetn,
			S_Axi_ArId					=> reg_axi_ms.arid,
			S_Axi_ArAddr				=> reg_axi_ms.araddr,
			S_Axi_Arlen					=> reg_axi_ms.arlen,
			S_Axi_ArSize				=> reg_axi_ms.arsize,
			S_Axi_ArBurst				=> reg_axi_ms.arburst,
			S_Axi_ArLock				=> reg_axi_ms.arlock,
			S_Axi_ArCache				=> reg_axi_ms.arcache,
			S_Axi_ArProt				=> reg_axi_ms.arprot, 
			S_Axi_ArValid				=> reg_axi_ms.arvalid,
			S_Axi_ArReady				=> reg_axi_sm.arready,
			S_Axi_RId					=> reg_axi_sm.rid,
			S_Axi_RData					=> reg_axi_sm.rdata,
			S_Axi_RResp					=> reg_axi_sm.rresp,
			S_Axi_RLast					=> reg_axi_sm.rlast,
			S_Axi_RValid				=> reg_axi_sm.rvalid,
			S_Axi_RReady				=> reg_axi_ms.rready,
			S_Axi_AwAddr				=> reg_axi_ms.awaddr,
			S_AXi_AwId					=> reg_axi_ms.awid,
			S_Axi_AwLen					=> reg_axi_ms.awlen,
			S_Axi_AwSize				=> reg_axi_ms.awsize,
			S_Axi_AwBurst				=> reg_axi_ms.awburst,
			S_Axi_AwLock				=> reg_axi_ms.awlock,
			S_Axi_AwCache				=> reg_axi_ms.awcache,
			S_Axi_AwProt				=> reg_axi_ms.awprot,
			S_Axi_AwValid				=> reg_axi_ms.awvalid,
			S_Axi_AwReady				=> reg_axi_sm.awready,
			S_Axi_WData					=> reg_axi_ms.wdata,
			S_Axi_WStrb					=> reg_axi_ms.wstrb,
			S_Axi_WLast					=> reg_axi_ms.wlast,
			S_Axi_WValid				=> reg_axi_ms.wvalid,
			S_Axi_WReady				=> reg_axi_sm.wready,
			S_Axi_BId					=> reg_axi_sm.bid,
			S_Axi_BResp					=> reg_axi_sm.bresp,
			S_Axi_BValid				=> reg_axi_sm.bvalid,
			S_Axi_BReady				=> reg_axi_ms.bready,
			M_Axi_Aclk					=> M_Axi_Aclk,
			M_Axi_Aresetn				=> M_Axi_Aresetn,
			M_Axi_AwAddr				=> axi_ms.awaddr,								
			M_Axi_AwLen					=> axi_ms.awlen,
			M_Axi_AwSize				=> axi_ms.awsize,
			M_Axi_AwBurst				=> axi_ms.awburst,
			M_Axi_AwLock				=> axi_ms.awlock,
			M_Axi_AwCache				=> axi_ms.awcache,
			M_Axi_AwProt				=> axi_ms.awprot,
			M_Axi_AwValid				=> axi_ms.awvalid,
			M_Axi_AwReady				=> axi_sm.awready,                             					
			M_Axi_WData					=> axi_ms.wdata,
			M_Axi_WStrb					=> axi_ms.wstrb,
			M_Axi_WLast					=> axi_ms.wlast,
			M_Axi_WValid				=> axi_ms.wvalid,
			M_Axi_WReady				=> axi_sm.wready,                             
			M_Axi_BResp					=> axi_sm.bresp,
			M_Axi_BValid				=> axi_sm.bvalid,
			M_Axi_BReady				=> axi_ms.bready,                    
			M_Axi_ArAddr				=> axi_ms.araddr,
			M_Axi_ArLen					=> axi_ms.arlen,
			M_Axi_ArSize				=> axi_ms.arsize,
			M_Axi_ArBurst				=> axi_ms.arburst,
			M_Axi_ArLock				=> axi_ms.arlock,
			M_Axi_ArCache				=> axi_ms.arcache,
			M_Axi_ArProt				=> axi_ms.arprot,
			M_Axi_ArValid				=> axi_ms.arvalid,
			M_Axi_ArReady				=> axi_sm.arready,                          
			M_Axi_RData					=> axi_sm.rdata,
			M_Axi_RResp					=> axi_sm.rresp,
			M_Axi_RLast					=> axi_sm.rlast,
			M_Axi_RValid				=> axi_sm.rvalid,
			M_Axi_RReady				=> axi_ms.rready
		);
		
	------------------------------------------------------------
	-- Emulate Memory
	------------------------------------------------------------	
	p_mem : process
		variable Address_v		: integer;
		variable Size_v			: integer;
	begin
		axi_slave_init(axi_sm);
		wait until rising_edge(M_Axi_Aclk);
		while TbRunning loop
			axi_sm.awready <= '1';
			wait until (rising_edge(M_Axi_Aclk) and axi_ms.awvalid = '1') or (not TbRunning);
			if TbRunning then
				axi_sm.awready <= '0';
				axi_sm.wready <= '1';
				Address_v	:= to_integer(unsigned(axi_ms.awaddr));
				Size_v		:= to_integer(unsigned(axi_ms.awlen))+1;
				for qw in 0 to Size_v-1 loop
					wait until rising_edge(M_Axi_Aclk) and axi_ms.wvalid = '1';
					for byte in 0 to 7 loop
						if axi_ms.wstrb(byte) = '1' then
							Memory(Address_v+qw*8+byte) <= axi_ms.wdata(byte*8+7 downto byte*8);
						end if;
					end loop;
				end loop;
				StdlCompare(1, axi_ms.wlast, "Last not received at end of burst");
				axi_sm.wready <= '0';
				axi_sm.bresp <= xRESP_OKAY_c;
				axi_sm.bvalid <= '1';
				wait until rising_edge(M_Axi_Aclk) and axi_ms.bready = '1';
				axi_sm.bvalid <= '0';
			end if;
		end loop;
		wait;			
	end process;
	
	------------------------------------------------------------
	-- Clocks 
	------------------------------------------------------------	
	
	p_clk_axi_mem : process
		constant Frequency_c : real := real(200e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			M_Axi_Aclk <= not M_Axi_Aclk;
		end loop;
		wait;
	end process;
	
	p_clk_axi_reg : process
		constant Frequency_c : real := real(166e6);
	begin
		while TbRunning loop
			wait for 0.5*(1 sec)/Frequency_c;
			S_Axi_Aclk <= not S_Axi_Aclk;
		end loop;
		wait;
	end process;	
	
	g_clk_str : for i in 0 to StrCount_c-1 generate
		p_clk_str : process
		begin
			while TbRunning loop
				wait for 0.5*(1 sec)/(ClkFreq_c(i)+0.1e6);
				Str_Clk(i) <= not Str_Clk(i);
			end loop;
			wait;				
		end process;
	end generate;
		
	------------------------------------------------------------
	-- Reg-Access Process
	------------------------------------------------------------
	p_regacc  : process
		variable StartTime_v : time;
		variable Stream1Armed_v : boolean := false;
		variable Stream2Armed_v	: boolean := false;
	begin
		print("*** Info ***");
		print("This testbench does not print any status information by default (only errors).");
		print("To change this behavior, change the constant PrintDefault_c in psi_ms_daq_axi_tb_pkg.");
	
		axi_master_init(reg_axi_ms);
		wait for 1 us;
		S_Axi_Aresetn <= '1';
		M_Axi_Aresetn <= '1';
		
		-- *** Initial Configuration ***
		 AxiExpect32(16#0010#, 0, S_Axi_Aclk, reg_axi_ms, reg_axi_sm, "Inital IRQVEC");
		 AxiWriteAndRead32(16#0014#, 16#000F#, S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
		 AxiWriteAndRead32(16#0020#, 16#000F#, S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
		 -- Stream Setup
		 Str0Setup(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
		 Str1Setup(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
		 Str2Setup(S_Axi_Aclk, reg_axi_ms, reg_axi_sm); 
		 Str3Setup(S_Axi_Aclk, reg_axi_ms, reg_axi_sm); 
		 
		 -- Enable
		 AxiWriteAndRead32(16#0000#, 16#0101#, S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
		 
		 
		 -- *** Run Test ***
		 StartTime_v := now;
		 while now < StartTime_v+150 us loop
			wait until rising_edge(S_Axi_Aclk);
			-- IRQ Handling
			if Irq = '1' then
				IrqHandler(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
			end if;
			-- Regular actions
			Str0Update(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
			Str1Update(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
			Str2Update(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
			Str3Update(S_Axi_Aclk, reg_axi_ms, reg_axi_sm);
				
		 end loop;
		 TbRunning <= false;
		 
		 -- *** Check end state ***
		 assert Str0WinCheck >= 4 report "###ERROR###: Stream 0 checks not completed" severity error;
		 assert Str1WinCheck = 1 report "###ERROR###: Stream 1 checks not completed" severity error;
		 assert Str2WinCheck >= 2 report "###ERROR###: Stream 2 checks not completed"  severity error;
		 assert Str3WinCheck = 2 report "###ERROR###: Stream 3 checks not completed"  severity error;
		wait;
	end process;
	
	------------------------------------------------------------
	-- Timestamp Processes
	------------------------------------------------------------	
	g_ts : for i in 0 to StrCount_c-1 generate
		p_ts : process
		begin
			while TbRunning loop
				wait until rising_edge(Str_Clk(0));
				Timestamp(0) <= std_logic_vector(unsigned(Timestamp(0)) + 1);
			end loop;
			wait;
		end process;
	end generate;
	
	------------------------------------------------------------
	-- Data Generation Processes
	------------------------------------------------------------
	p_str0 : process
		variable IrqOn : boolean := false;
	begin
		wait until rising_edge(Str_Clk(0));
		while TbRunning loop
			Str0Sample(Str_Clk(0), Str_Vld(0), Str_Trig(0), Str0_Data);	
		end loop;
		wait;
	end process;
	
	p_str1 : process
	begin
		Str1Data(Str_Clk(1), Str_Vld(1), Str_Trig(1), Str1_Data);
		wait;
	end process;
	
	p_str2 : process
	begin
		Str2Data(Str_Clk(2), Str_Vld(2), Str_Trig(2), Str2_Data);
		wait;
	end process;	
	
	p_str3 : process
	begin
		Str3Data(Str_Clk(3), Str_Vld(3), Str_Trig(3), Str3_Data);
		wait;
	end process;		
	
	------------------------------------------------------------
	-- Check Process
	------------------------------------------------------------	
	
end;
